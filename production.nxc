const short wheelradius=28; //wheel radius, in mm
const short wheelbase=272; // distance between drive wheels, in mm.

const short motorMin=22; //minimum speed to make drive motor move;

const byte motorL=OUT_B;
const byte motorR=OUT_C;
const byte motorS=OUT_A;

const int soundMin=12;

const int sortAngle=70;
const int cansPerSide=3;

const int trashGoal[]={1500,-1050};
const int nukeGoal[]={100,1000};

const float thetaProportion=wheelradius/wheelbase;


// !!!!!!!!!!!  Unless intentionally resetting motor counters, use motorEX commands with flag RESET_NONE


float posX = 0;
float posY = 0;
float posT = 0;
float prevT = 0;
int prevL=0;
int prevR=0;

int margin=0;
int goalX=0;
int goalY=0;
int goalT=0;
int speed=0;

int resumeCourse[][];

mutex driveControlMutex;
bool externalControl=FALSE;

void goToPoint(int goalXgtp,int goalYgtp,int marginGtp) {

  margin=marginGtp;
  goalX=goalXgtp;
  goalY=goalYgtp;

  int deltaX=0;
  int deltaY=100;
  while((sqrt(pow(deltaX,2)+pow(deltaY,2)))>margin) {
    deltaX=posX-goalX;
    deltaY=goalY-posY;
  
    goalT=atan2d(deltaX,deltaY);
    goalT+=360;
    goalT%=360;
    
    speed = sqrt(pow(deltaX,2)+pow(deltaY,2));
    
    speed/=3;

    if (speed>100) {
       speed=100;
    } else if (speed<(-100)) {
       speed=(-100);
    }
    
    
    Wait(8);
    

  }
  speed=0;
  PlayTone(620, 200);
  //Wait(10);
  return;
}


void deposit() {
          Acquire(driveControlMutex);
          externalControl=TRUE;
          OnFwdEx(motorR, -70, RESET_NONE);
          OnFwdEx(motorL, -70, RESET_NONE);
          Wait(800);
          PlayTone(400,400);
          externalControl=FALSE;
          Release(driveControlMutex);
}


task sweep() {

//goalT=180;
//speed=0;

//    goToPoint(0,400,20); //pass 1 to goal
//
//    goToPoint(200,400,10); //turn
//
//    goToPoint(0,-680,20); //pass 2 - toward train
//
//    goToPoint(200,-680,10); //turn
//
//    goToPoint(350,800,40); //pass 3
//
//    goToPoint(600,1000,10); //turn
//
//    goToPoint(400,-580,20); //pass 4 - toward train
//
//    goToPoint(600,-590,10); //turn
//
//    goToPoint(800,1000,20); //pass 5
//
//    goToPoint(1000,1050,10); //turn
//
//    goToPoint(800,-600,20); //pass 6 - toward train side midpoint(ish)
//
//    goToPoint(1000,-750,10); //turn
//
//    goToPoint(1200,1050,20); //pass 7
//
//    goToPoint(1400,1050,10); //turn
//
//    goToPoint(1200,-600,20); //pass 8 - toward train side
//
//    goToPoint(1200,-600,10); //turn
//
//    goToPoint(1500,1050,20); //pass 9

//goToPoint(200,200,20);
//
//goToPoint(250,550,100);
//
//goToPoint(300,900,20);  //drop in goal.
//
//deposit();
//
//goToPoint(1000,250,10);
//
//// goToPoint(1800,0,10);
//
//goToPoint(2300,-1050,10);

//deposit();





}

task driveTask() {
   while (TRUE) {
          if (externalControl==FALSE) {
          Acquire(driveControlMutex);

          int deltaT=(goalT-posT);
          if (deltaT>180) {
            deltaT-=360;
          } else if (deltaT<-180) {
            deltaT+=360;
          }
          
          int speedL=speed-deltaT;
          int speedR=speed+deltaT;
          
          if (speedL<0) {
            speedL=((100-motorMin)*speedL/100);
            speedL-=motorMin;
          } else if(speedL>0) {
            speedL=((100-motorMin)*speedL/100);
            speedL+=motorMin;
          } else {
            OffEx(motorL, RESET_NONE);
          }

          if (speedR<0) {
            speedR=((100-motorMin)*speedR/100);
            speedR-=motorMin;
          } else if(speedR>0) {
            speedR=((100-motorMin)*speedR/100);
            speedR+=motorMin;
          } else {
            OffEx(motorR, RESET_NONE);
          }
          
          if(abs(speedL)>100 || abs(speedR)>100) {
            int maxSpeed=0;
            if (abs(speedL)>abs(speedR)) {
               maxSpeed=abs(speedL);
            } else {
               maxSpeed=abs(speedR);
            }
            speedL*=100;
            speedL/=maxSpeed;
            speedR*=100;
            speedR/=maxSpeed;
          }

          TextOut(1, LCD_LINE1, "         x   y" );
          TextOut(1, LCD_LINE2, "pos" );
          NumOut(40, LCD_LINE2, floor(posX));
          NumOut(75, LCD_LINE2, floor(posY));
          TextOut(1, LCD_LINE3, "goal" );
          NumOut(40, LCD_LINE3, floor(goalX));
          NumOut(75, LCD_LINE3, floor(goalY));
          TextOut(1, LCD_LINE4, "Btn");
          NumOut(60, LCD_LINE4, SENSOR_3);
          //NumOut(60, LCD_LINE4, floor(sqrt(pow(deltaX,2)+pow(deltaY,2))));
          TextOut(1, LCD_LINE5, "goal T" );
          NumOut(60, LCD_LINE5, floor(goalT));
          TextOut(1, LCD_LINE6, "pos T" );
          NumOut(60, LCD_LINE6, floor(posT));
          TextOut(1, LCD_LINE8, "motr spd" );
          NumOut(75, LCD_LINE8, speedL);
          NumOut(40, LCD_LINE8, speedR);

          
          OnFwdEx(motorR, speedR, RESET_NONE);
          OnFwdEx(motorL, speedL, RESET_NONE);

          Release(driveControlMutex);
          
   } //end if

    Wait(20);
    
    ClearScreen();
  }
}


task positionTask() {
  while (true) {

    int tachR = MotorBlockTachoCount(motorR);
    int tachL = MotorBlockTachoCount(motorL);

    posT=(tachR-tachL)*thetaProportion;
    posT%=360;
    posT+=360;
    posT%=360;
    
    float distMag=(tachR-prevR)+(tachL-prevL);      // the magnitude of the distance, in degrees of wheel turn.
    distMag*=21.99114857512;
    distMag/=90;

    posX-=distMag*sind(posT);
    posY+=distMag*cosd(posT);
    
    Wait(floor(speed));
    
    //ClearScreen();
    prevR=tachR;
    prevL=tachL;
  }
}


task sorter() {
  while(FALSE) {
  
    if (SENSOR_4==1) {  //if touch sensor is touched
        resumeCourse[ArrayLen(resumeCourse)][0]=goalX;
        resumeCourse[ArrayLen(resumeCourse)][1]=goalY;
        resumeCourse[ArrayLen(resumeCourse)][2]=margin;
        if (SENSOR_2 > soundMin) {   //nuclear

        } else {  //Trash

        }
    }


//    int color=Random(3);
//    switch (color) {
//      case 1 :
//        //blue
//        RotateMotorEx(motorS,70,sortAngle,0,FALSE,TRUE);
//        Wait(800);
//        RotateMotorEx(motorS,70,-sortAngle,0,FALSE,TRUE);
//        break;
//      case 2 :
//        //yellow
//        RotateMotorEx(motorS,70,-sortAngle,0,FALSE,TRUE);
//        Wait(800);
//        RotateMotorEx(motorS,70,sortAngle,0,FALSE,TRUE);
//        break;
//    }
//    Wait(800);

  }
}


task screen() {


}


task main() {
     OffEx(OUT_ABC,RESET_ALL);
     posT=0;
     prevT=posT;
     SetSensorUltrasonic(S1);        //set up ultrasonic sensor S1
     SetSensorSound(S2);             //set up sound sensor S2
     SetSensorLight(S3,false);       //set up light sensor S3
     SetSensor(S4, SENSOR_TOUCH);    //set up touch sensor S4

  Precedes(driveTask,positionTask,sweep,sorter);
}
