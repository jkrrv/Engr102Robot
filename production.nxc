const short wheelradius=28; //wheel radius, in mm
const short wheelbase=267; // distance between drive wheels, in mm.

const short motorMin=18; //minimum speed to make drive motor move;

const byte motorL=OUT_B;
const byte motorR=OUT_C;

const float thetaProportion=wheelradius/wheelbase;
//mutex moveMutex;


// !!!!!!!!!!!  Unless intentionally resetting motor counters, use motorEX commands with flag RESET_NONE


float posX = 0;
float posY = 0;
float posT = 0;
float prevT = 0;
int prevL=0;
int prevR=0;


int goalT=180;
int speed=0;



void goToPoint(int goalX,int goalY,int margin) {
  int deltaX=posX-goalX;
  int deltaY=goalY-posY;
  
  goalT=atan2d(deltaX,deltaY);
  
}

task control() {

    goToPoint(100,100,20);

    speed=10;
    Wait(2000);
    speed=0;
    Wait(2000);
    speed=-20;
    Wait(2000);
    speed=0;
    Wait(2000);

}

task driveTask() {
   while (true) {

          int deltaT=(goalT-posT);
          if (deltaT>180) {
            deltaT-=360;
          } else if (deltaT<-180) {
            deltaT+=360;
          }
          
          int speedL=speed-deltaT;
          int speedR=speed+deltaT;
          
          if (speedL<0) {
            speedL=((100-motorMin)*speedL/100);
            speedL-=motorMin;
          } else if(speedL>0) {
            speedL=((100-motorMin)*speedL/100);
            speedL+=motorMin;
          } else {
            OffEx(motorL, RESET_NONE);
          }

          if (speedR<0) {
            speedR=((100-motorMin)*speedR/100);
            speedR-=motorMin;
          } else if(speedR>0) {
            speedR=((100-motorMin)*speedR/100);
            speedR+=motorMin;
          } else {
            OffEx(motorR, RESET_NONE);
          }
          
          if(abs(speedL)>100 || abs(speedR)>100) {
            int maxSpeed=0;
            if (abs(speedL)>abs(speedR)) {
               maxSpeed=abs(speedL);
            } else {
               maxSpeed=abs(speedR);
            }
            speedL*=100;
            speedL/=maxSpeed;
            speedR*=100;
            speedR/=maxSpeed;
          }
          
          

          TextOut(1, LCD_LINE1, "dT" );
          NumOut(50, LCD_LINE1, deltaT);
          TextOut(1, LCD_LINE2, "motr spd" );
          NumOut(75, LCD_LINE2, speedL);
          NumOut(50, LCD_LINE2, speedR);

          
          OnFwdEx(motorR, speedR, RESET_NONE);
          OnFwdEx(motorL, speedL, RESET_NONE);

    Wait(20);
    
  //  ClearScreen();
  }
}

float magSum=0;

task positionTask() {
  while (true) {

    int tachR = MotorBlockTachoCount(motorR);
    int tachL = MotorBlockTachoCount(motorL);

    posT=(tachR-tachL)*thetaProportion;
    posT%=360;
    posT+=360;
    posT%=360;
    
    float distMag=(tachR-prevR)+(tachL-prevL);      // the magnitude of the distance, in degrees of wheel turn.
    distMag*=21.99114857512;
    distMag/=90;

    posX-=distMag*sind(posT);
    posY+=distMag*cosd(posT);


    TextOut(1, LCD_LINE3, "position" );
    NumOut(50, LCD_LINE3, floor(posX));
    NumOut(75, LCD_LINE3, floor(posY));
    
    magSum+=distMag;
    NumOut(63, LCD_LINE4, magSum);
    
    TextOut(1, LCD_LINE5, "posT  sind  cosd");
    posT=floor(posT);
    NumOut(1, LCD_LINE6, posT);
    NumOut(30, LCD_LINE6, sind(posT));
    NumOut(67, LCD_LINE6, cosd(posT));
    
    Wait(30);
    
    ClearScreen();
    prevR=tachR;
    prevL=tachL;
  }
}


task main() {
     OffEx(OUT_ABC,RESET_ALL);
     posT=0;
     prevT=posT;
     SetSensorUltrasonic(S1);        // set up ultrasonic sensor S1
     //set up ??? sensor S2
     //set up light sensor S3
     //set up color sensor S4

  Precedes(driveTask,positionTask,control);
}
