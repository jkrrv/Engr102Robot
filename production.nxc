const short wheelradius=28; //wheel radius, in mm
const short wheelbase=267; // distance between drive wheels, in mm.

const float thetaProportion=wheelradius/wheelbase;


// !!!!!!!!!!!  Unless intentionally resetting motor counters, use motorEX commands with flag RESET_NONE


mutex moveMutex;
float posX = 0;
float posY = 0;
float posT = 0;

int goalT=90;
int speed=100;


task driveTask() {
   while (true) {
      if (posT!=goalT) {
          int deltaT=(goalT-posT)/2;
          int speedL=speed-deltaT+abs(deltaT);
          int speedR=speed+deltaT+abs(deltaT);
          
          if(abs(speedL)>100 || abs(speedR)>100) {
            int maxSpeed=0;
            if (abs(speedL)>abs(speedR)) {
               maxSpeed=abs(speedL);
            } else {
               maxSpeed=abs(speedR);
            }
            speedL/=maxSpeed;
            speedL*=100;
            speedR/=maxSpeed;
            speedR*=100;


          }



             NumOut(1, LCD_LINE2, speedL);
             NumOut(1, LCD_LINE3, speedR);
          
          OnFwdEx(OUT_C, speedR, RESET_NONE);
          OnFwdEx(OUT_B, speedL, RESET_NONE);
        } else {
          OnFwdEx(OUT_BC,speed,RESET_NONE);
        }
          


    NumOut(1, LCD_LINE1, posT);
    

    Wait(20);
    
    ClearScreen();
  }
}


task positionTask() {
  while (true) {


    posT=(MotorBlockTachoCount(OUT_C)-MotorBlockTachoCount(OUT_B))*thetaProportion;
    posT%=360;
    posT+=360;
    posT%=360;



    Wait(20);
  }
}


task main() {
     SetSensorUltrasonic(S1);        // set up ultrasonic sensor S1
     //set up ??? sensor S2
     //set up light sensor S3
     //set up color sensor S4
  
  Precedes(driveTask,positionTask);
}
