const short wheelradius=28; //wheel radius, in mm
const short wheelbase=267; // distance between drive wheels, in mm.

const short motorMin=18; //minimum speed to make drive motor move;

const byte motorL=OUT_B;
const byte motorR=OUT_C;

const float thetaProportion=wheelradius/wheelbase;
//mutex moveMutex;


// !!!!!!!!!!!  Unless intentionally resetting motor counters, use motorEX commands with flag RESET_NONE


float posX = 0;
float posY = 0;
float posT = 0;
float prevT = 0;
int prevL=0;
int prevR=0;


int goalT=0;
int speed=0;



void goToPoint(int goalX,int goalY,int margin) {
  bool done=FALSE;
  int deltaX=9999999;
  int deltaY=9999999;
  while((sqrt(pow(deltaX,2)+pow(deltaY,2)))>margin) {
    deltaX=posX-goalX;
    deltaY=goalY-posY;
  
    goalT=atan2d(deltaX,deltaY);
    
    speed = sqrt(pow(deltaX,2)+pow(deltaY,2));
    if (speed<margin) {
       done=TRUE;
    }
    
    speed/=3;
    
    if (speed>100) {
       speed=100;
    } else if (speed<(-100)) {
       speed=(-100);
    }
    
    TextOut(1, LCD_LINE3, "goal" );
    NumOut(40, LCD_LINE3, floor(goalX));
    NumOut(75, LCD_LINE3, floor(goalY));
    TextOut(1, LCD_LINE4, "goal dist" );
    NumOut(60, LCD_LINE4, floor(sqrt(pow(deltaX,2)+pow(deltaY,2))));
    TextOut(1, LCD_LINE5, "goal T" );
    NumOut(60, LCD_LINE5, floor(goalT));
    
    Wait(3);
  }
  speed=0;
  Wait(10);
  return;
}

task control() {

    goToPoint(0,500,100);
    
    PlayTone(440, 500);

    //speed=60;
    //Wait(2000);
    //speed=0;
    //Wait(2000);
    //speed=-20;
    //Wait(2000);
    //speed=0;
    //Wait(2000);

}

task driveTask() {
   while (true) {

          int deltaT=(goalT-posT);
          if (deltaT>180) {
            deltaT-=360;
          } else if (deltaT<-180) {
            deltaT+=360;
          }
          
          int speedL=speed-deltaT;
          int speedR=speed+deltaT;
          
          if (speedL<0) {
            speedL=((100-motorMin)*speedL/100);
            speedL-=motorMin;
          } else if(speedL>0) {
            speedL=((100-motorMin)*speedL/100);
            speedL+=motorMin;
          } else {
            OffEx(motorL, RESET_NONE);
          }

          if (speedR<0) {
            speedR=((100-motorMin)*speedR/100);
            speedR-=motorMin;
          } else if(speedR>0) {
            speedR=((100-motorMin)*speedR/100);
            speedR+=motorMin;
          } else {
            OffEx(motorR, RESET_NONE);
          }
          
          if(abs(speedL)>100 || abs(speedR)>100) {
            int maxSpeed=0;
            if (abs(speedL)>abs(speedR)) {
               maxSpeed=abs(speedL);
            } else {
               maxSpeed=abs(speedR);
            }
            speedL*=100;
            speedL/=maxSpeed;
            speedR*=100;
            speedR/=maxSpeed;
          }
          
          

          TextOut(1, LCD_LINE1, "         x   y" );
          
          
          TextOut(1, LCD_LINE8, "motr spd" );
          NumOut(75, LCD_LINE8, speedL);
          NumOut(40, LCD_LINE8, speedR);

          
          OnFwdEx(motorR, speedR, RESET_NONE);
          OnFwdEx(motorL, speedL, RESET_NONE);

    Wait(20);
    
  //  ClearScreen();
  }
}

task positionTask() {
  while (true) {

    int tachR = MotorBlockTachoCount(motorR);
    int tachL = MotorBlockTachoCount(motorL);

    posT=(tachR-tachL)*thetaProportion;
    posT%=360;
    posT+=360;
    posT%=360;
    
    float distMag=(tachR-prevR)+(tachL-prevL);      // the magnitude of the distance, in degrees of wheel turn.
    distMag*=21.99114857512;
    distMag/=90;

    posX-=distMag*sind(posT);
    posY+=distMag*cosd(posT);


    TextOut(1, LCD_LINE2, "pos" );
    NumOut(40, LCD_LINE2, floor(posX));
    NumOut(75, LCD_LINE2, floor(posY));
    
    Wait(floor(speed));
    
    ClearScreen();
    prevR=tachR;
    prevL=tachL;
  }
}


task main() {
     OffEx(OUT_ABC,RESET_ALL);
     posT=0;
     prevT=posT;
     SetSensorUltrasonic(S1);        // set up ultrasonic sensor S1
     //set up ??? sensor S2
     //set up light sensor S3
     //set up color sensor S4

  Precedes(driveTask,positionTask,control);
}
